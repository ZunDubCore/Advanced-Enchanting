buildscript {
    repositories {
        maven {
            name 'forge'
            url 'https://files.minecraftforge.net/maven'
        }
        jcenter()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}

plugins {
    id 'com.matthewprenger.cursegradle' version '1.4.0'
    id 'org.ajoberstar.grgit' version '4.0.2'
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'maven-publish'
}

apply plugin: 'net.minecraftforge.gradle'

import groovy.json.JsonSlurper

if (project.hasProperty('secretFile')) {
    loadSecrets(new File((String) findProperty('secretFile')))
}

version = "${minecraft_version}-${mod_version}." + getBuildNumber()
archivesBaseName = "${mod_name}".replaceAll("\\s", "")

def forge = "${minecraft_version}-${forge_version}"

// Need this here so eclipse task generates correctly.
sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'

minecraft {
    // The mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   Snapshot are built nightly.
    // stable_#            Stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not always work.
    // Simply re-run your setup task after changing the mappings to update your workspace.
    mappings channel: 'snapshot', version: "${mcp_version}".toString()
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        client {
            workingDirectory project.file('run')
            taskName "${mod_name}".replaceAll("\\s", "") + 'Client'

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')
            taskName "${mod_name}".replaceAll("\\s", "") + 'Server'

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')
            taskName "${mod_name}".replaceAll("\\s", "") + 'Data'

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            args '--mod', "${mod_id}".toString(), '--all', '--output', file('src/generated/resources/')

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }
    }
}

repositories {
    maven {
        name 'MCModDev - Bookshelf'
        url 'https://maven.mcmoddev.com'
    }
    maven {
        name "Progwml6 - JEI"
        url 'http://dvs1.progwml6.com/files/maven'
    }
    maven {
        name 'BlameJared - Crafttweaker'
        url 'http://maven.blamejared.com'
    }
}


dependencies {
    // Specify the version of Minecraft to use, If this is any group other then 'net.minecraft' it is assumed
    // that the dep is a ForgeGradle 'patcher' dependency. And it's patches will be applied.
    // The userdev artifact is a special name and will get all sorts of transformations applied to it.

    minecraft "net.minecraftforge:forge:${forge}"

    // You may put jars on which you depend on in ./libs or you may define them like so..
    // compile "some.group:artifact:version:classifier"
    // compile "some.group:artifact:version"

    // Real examples
    // compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
    // compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

    // The 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
    // provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // These dependencies get remapped to your current MCP mappings
    // deobf 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // For more info...
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html
}

def properties = ['version'             : project.version,
                  'minecraft_version'   : minecraft_version,
                  'min_forge_version'   : min_forge_version,
                  'loader_version'      : loader_version,
                  'mod_name'            : mod_name,
                  'bookshelf_version'   : bookshelf_version,
                  'crafttweaker_version': crafttweaker_version,
                  'jei_version'         : jei_version,
                  'mod_id'              : mod_id,
                  'mod_credits'         : mod_credits,
                  'mod_authors'         : mod_authors,
                  'mod_description'     : mod_description]

// Process resources on build
processResources {
    // This will ensure that this task is redone when the versions change.
    inputs.property 'version', project.version

    // Replace stuff in mods.toml, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'META-INF/mods.toml'

        // Replace version
        expand properties
    }

    // Copy everything else except the mods.toml
    from(sourceSets.main.resources.srcDirs) {
        exclude 'META-INF/mods.toml'
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {

    description = 'Creates a JAR containing the source code.'
    from sourceSets.main.allSource
    classifier = 'sources'
}

task javadocJar(type: Jar, dependsOn: javadoc) {

    description = 'Creates a JAR containing the JavaDocs.'
    from javadoc.destinationDir
    classifier = 'javadoc'
}

task deobfJar(type: Jar) {

    description = 'Creates a JAR containing the non-obfuscated compiled code.'
    from sourceSets.main.output
    classifier = "deobf"
}

task forgelibJar(type: Jar) {
    description = 'Creates a compiled JAR which also contains raw sources.'
    from sourceSets.main.output
    from sourceSets.main.allJava
    classifier = 'forgelib'
}

tasks.build.dependsOn sourcesJar

//Adds the artifact types added by this script to the actual artifacts list.
artifacts {
    archives sourcesJar
    archives javadocJar
    archives deobfJar
    archives forgelibJar
}

String getBuildNumber() {
    return System.getenv('BUILD_NUMBER') ? System.getenv('BUILD_NUMBER') :
            System.getenv('TRAVIS_BUILD_NUMBER') ? System.getenv('TRAVIS_BUILD_NUMBER') : '0'
}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
    manifest {
        attributes([
                'Timestamp'               : System.currentTimeMillis(),
                'Specification-Title'     : "${mod_name}",
                'Specification-Vendor'    : "${mod_vendor}",
                'Specification-Version'   : "${version}",
                'Implementation-Title'    : project.archivesBaseName,
                'Implementation-Version'  : project.version,
                'Implementation-Vendor'   : "${mod_vendor}",
                'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                'Built-On-Java'           : "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
                'Built-On'                : "${forge}"
        ])
    }
}

// Example configuration to allow publishing using the maven-publish task
// This is the preferred method to reobfuscate your jar file
// jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
//publish.dependsOn('reobfJar')

tasks.curseforge.dependsOn jar, sourcesJar

if (System.getenv("CURSEFORGE_KEY") != null || project.hasProperty('curseforgeKey')) {

    println "Enabling Curseforge config"

    curseforge {

        apiKey = System.getenv("CURSEFORGE_KEY") ?: project.findProperty("curseforgeKey")

        def generatedChangelog = "Unable to generate changelog :("
        def currentCommit = System.getenv("GIT_COMMIT")
        def prevCommit = System.getenv("GIT_PREVIOUS_SUCCESSFUL_COMMIT") ?: System.getenv("GIT_PREVIOUS_COMMIT")

        // TODO: This only works in a CI. Add proper CI system
        if (currentCommit != null && prevCommit != null) {

            generatedChangelog = ""

            grgit.log {
                range(prevCommit, currentCommit)
            }.reverse().each {commit ->

                String message = commit.shortMessage

                if (!message.startsWith("Merge branch") && !message.startsWith("Merge pull request")) {

                    // Ignore PRs and Merges
                    // Turn issues/prs into links (github currently supports prs being linked as issues)

                    message = message.replaceAll("#(\\d+)", {match ->
                        return "<a href=\"https://github.com/ZunDubCore/Advanced-Enchanting/issues/${match[1]}\">${match[0]}</a>"
                    })

                    if (generatedChangelog != "") {
                        generatedChangelog += "<br>"
                    }

                    generatedChangelog +=
                            "<a href=\"https://github.com/ZunDubCore/Advanced-Enchanting/commit/${commit.id}\">${commit.getAbbreviatedId()}</a> - ${message}\n"
                }
            }

            println "Changelog generated"
        }

        def releaseNotesFile = project.file("docs/release_${mod_version}.html")

        if (releaseNotesFile.exists()) {
            //Add any version specific changelog stuff
            def releaseNotes = releaseNotesFile.getText()
            generatedChangelog = "$releaseNotes<br> $generatedChangelog"
        }

        if (curse_release_type == "alpha") {
            //Add a warning at the top about what an alpha build means
            generatedChangelog = "Warning: Advanced Enchanting is currently in alpha, and is not " +
                    "recommended for widespread use in modpacks. There are likely to be game " +
                    "breaking bugs, and updating from one alpha to the next may cause various " +
                    "blocks to disappear/void their contents. While we will try to not have this " +
                    "happen/keep it to a minimum, make sure to make backups." +
                    "<br> $generatedChangelog"
        }

        project {
            id = "${curse_project_id}"
            changelogType = 'html'
            changelog = "${generatedChangelog}"
            releaseType = "${curse_release_type}"
            addGameVersion "${minecraft_version}"

            mainArtifact jar

            addArtifact sourcesJar
        }
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact jar
        }
    }
    repositories {
        maven {
            url "file:///${project.projectDir}/mcmodsrepo"
        }
    }
}

/*
 This Gradle script provides a way to load values from a Json file into the project properties.
 Properties are named with the key value from the Json, and the value is the json value.
*/

// Loads secrets using a secrets.json file or a file path specified by the environment.
def loadSecrets() {
    final def secretFile = file System.getenv('SECRET_FILE') ?: 'secrets.json'
    loadSecrets(secretFile)
}

// Loads secrets using a specified json file.
def loadSecrets(secretFile) {

    if (secretFile.exists()) {

        secretFile.withReader {

            Map secretMap = new JsonSlurper().parse it

            for (entry in secretMap) {

                project.ext.set(entry.key, entry.value)
            }

            project.logger.info('Successfully loaded ' + secretMap.size() + ' secret properties')
        }
    }
    else {
        project.logger.warn('The secret file ' + secretFile.getName() + ' could not be loaded. It does not exist.')
    }
}
